#include "minishell.h"

#include <assert.h>

#include <criterion/criterion.h>
#include <criterion/new/assert.h>


Test(input_is_space, simple_tests)
{
	assert( input_is_space("     ") == true);
	assert( input_is_space("  abc  ") == false);
}


Test(tokenization, quotes) {
	t_global global;
	global.token = NULL;
	global.env = NULL;
	global.user_input = "\'abc";
	assert( tokenization(&global) == 1);
}


Test(tokenization, three_tokens) {
	t_global global;
	global.token = NULL;
	global.env = NULL;

	global.user_input = "abc    def      xyz";
	assert( tokenization(&global) == 0);

	t_token* temp = global.token;
	assert ( ft_strncmp(temp->str, "abc", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert ( ft_strncmp(temp->str, "def", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert ( ft_strncmp(temp->str, "xyz", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert(temp->type == END);

}
// GENERATED BY CHATGPT
// and updated


t_token *create_token(char *str, int type) {
    t_token *new_token = malloc(sizeof(t_token));
    new_token->str = strdup(str);
    new_token->type = type;
    new_token->status = 0;
    new_token->prev = NULL;
    new_token->next = NULL;
    return new_token;
}

void free_tokens(t_token *head) {
    t_token *temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp->str);
        free(temp);
    }
}

Test(check_var, pipe_at_beginning) {
    t_token *head = create_token("|", PIPE);
    cr_expect(check_var(&head) == 1, "Expected syntax error for pipe at beginning");
    free_tokens(head);
}

Test(check_var, variable_detection) {
    t_token *head = create_token("$VAR", 0);
    cr_expect(check_var(&head) == 0, "Expected no error for variable token");
    cr_expect(head->type == VAR, "Expected token type to be VAR");
    free_tokens(head);
}

Test(check_var, consecutive_pipes) {
    t_token * head = create_token("abc", WORD);
    t_token *token1 = create_token("|", PIPE);
    t_token *token2 = create_token("|", PIPE);
    t_token *token3 = create_token("def", WORD);

    head->next = token1;
    token1->prev = head;

    token1->next = token2;
    token2->prev = token1;

    token2->next = token3;
    token3->prev = token2;
    cr_expect(check_var(&head) == 1, "Expected syntax error for consecutive pipes");
    free_tokens(head);
}

Test(check_var, mixed_valid_tokens) {
    t_token *head = create_token("echo", WORD);
    head->next = create_token("$HOME", VAR);
    head->next->prev = head;
    cr_expect(check_var(&head) == 0, "Expected no error for valid tokens");
    free_tokens(head);
}


// var_expander


// Helper function to create a mock global env
t_global *create_mock_global(char **env) {
    t_global *global = malloc(sizeof(t_global));
    global->env = env;
    return global;
}

// Test variable expansion
Test(var_expander, expands_simple_variable) {
    char *env[] = {"USER=testuser", "HOME=/home/testuser", NULL};
    t_global *global = create_mock_global(env);
    t_token *token = create_token("$USER", VAR);
    
    var_expander(global, &token);
    
    cr_assert_str_eq(token->str, "testuser", "Expected USER to expand to testuser");
    free(token->str);
    free(token);
    free(global);
}

// Test expansion of $? special variable
Test(var_expander, expands_exit_code) {
    char *env[] = {NULL};
    t_global *global = create_mock_global(env);
    g_last_exit_code = 42;
    t_token *token = create_token("$?", VAR);
    
    var_expander(global, &token);
    
    cr_assert_str_eq(token->str, "42", "Expected $? to expand to 42");
    free(token->str);
    free(token);
    free(global);
}

// Test handling of non-existent variable
Test(var_expander, non_existent_variable) {
    char *env[] = {"USER=testuser", NULL};
    t_global *global = create_mock_global(env);
    t_token *token = create_token("$FOO", VAR);
    
    var_expander(global, &token);
    
    cr_assert_str_eq(token->str, "", "Expected non-existent variable to be removed");
    free(token->str);
    free(token);
    free(global);
}

// Test variable expansion inside quotes
Test(var_expander, expands_within_double_quotes) {
    char *env[] = {"USER=testuser", NULL};
    t_global *global = create_mock_global(env);
    t_token *token = create_token("\"$USER\"", VAR);
    
    var_expander(global, &token);
    
    cr_assert_str_eq(token->str, "\"testuser\"", "Expected expansion inside double quotes");
    free(token->str);
    free(token);
    free(global);
}

// Test variable not expanding inside single quotes
Test(var_expander, does_not_expand_within_single_quotes) {
    char *env[] = {"USER=testuser", NULL};
    t_global *global = create_mock_global(env);
    t_token *head = create_token("echo", WORD);
    t_token *token = create_token("'$USER'", VAR);
    
    head->next = token;
    token->prev = head;

    var_expander(global, &head);
    
    cr_assert_str_eq(head->str, "echo");
    cr_assert_str_eq(token->str, "'$USER'", "Expected no expansion inside single quotes");
    free(head->str);
    free(head);
    free(token);
    free(global);
}

// quotes

Test(handle_quotes, remove_single_quotes) {
	t_token *head = create_token("'hello'", WORD);
	t_global global = {.token = head};

	handle_quotes(&global);

	assert(strcmp(head->str, "hello") == 0);
	assert(head->join == true);

	free_tokens(head);
}

Test(handle_quotes, remove_double_quotes) {
	t_token *head = create_token("\"world\"", WORD);
	t_global global = {.token = head};

	handle_quotes(&global);

	assert(strcmp(head->str, "world") == 0);
	assert(head->join == true);

	free_tokens(head);
}

Test(handle_quotes, mixed_quotes_inside_string) {
	t_token *head = create_token("The 'quick' brown \"fox\"", WORD);
	t_global global = {.token = head};

	handle_quotes(&global);

	assert(strcmp(head->str, "The quick brown fox") == 0);
	assert(head->join == true);

	free_tokens(head);
}

Test(handle_quotes, no_quotes_should_remain_unchanged) {
	t_token *head = create_token("justtext", WORD);
	t_global global = {.token = head};

	handle_quotes(&global);

	assert(strcmp(head->str, "justtext") == 0);
	assert(head->join == false);

	free_tokens(head);
}

Test(handle_quotes, heredoc_should_not_remove_quotes) {
	t_token *heredoc = create_token("<<", HEREDOC);
	t_token *quoted_token = create_token("'do_not_remove'", WORD);

	heredoc->next = quoted_token;
	quoted_token->prev = heredoc;

	t_global global = {.token = heredoc};

	handle_quotes(&global);

	assert(strcmp(quoted_token->str, "'do_not_remove'") == 0);
	assert(quoted_token->join == false);

	free_tokens(heredoc);
}

Test(handle_quotes, multiple_tokens_mixed) {
	t_token *t1 = create_token("'alpha'", WORD);
	t_token *t2 = create_token("\"beta\"", WORD);
	t_token *t3 = create_token("gamma", WORD);

	t1->next = t2; t2->prev = t1;
	t2->next = t3; t3->prev = t2;

	t_global global = {.token = t1};

	handle_quotes(&global);

	assert(strcmp(t1->str, "alpha") == 0);
	assert(strcmp(t2->str, "beta") == 0);
	assert(strcmp(t3->str, "gamma") == 0);
	assert(t1->join == true);
	assert(t2->join == true);
	assert(t3->join == false);

	free_tokens(t1);
}