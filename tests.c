#include "minishell.h"

#include <assert.h>

#include <criterion/criterion.h>
#include <criterion/new/assert.h>


Test(input_is_space, simple_tests)
{
	assert( input_is_space("     ") == true);
	assert( input_is_space("  abc  ") == false);
}


Test(tokenization, quotes) {
	t_global global;
	global.token = NULL;
	global.env = NULL;
	global.user_input = "\'abc";
	assert( tokenization(&global) == 1);
}


Test(tokenization, three_tokens) {
	t_global global;
	global.token = NULL;
	global.env = NULL;

	global.user_input = "abc    def      xyz";
	assert( tokenization(&global) == 0);

	t_token* temp = global.token;
	assert ( ft_strncmp(temp->str, "abc", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert ( ft_strncmp(temp->str, "def", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert ( ft_strncmp(temp->str, "xyz", ft_strlen(temp->str)) == 0 );
	assert ( temp->type == WORD );
	temp = temp->next;

	assert(temp->type == END);

}
// GENERATED BY CHATGPT
// and updated


t_token *create_token(char *str, int type) {
    t_token *new_token = malloc(sizeof(t_token));
    new_token->str = strdup(str);
    new_token->type = type;
    new_token->status = 0;
    new_token->prev = NULL;
    new_token->next = NULL;
    return new_token;
}

void free_tokens(t_token *head) {
    t_token *temp;
    while (head) {
        temp = head;
        head = head->next;
        free(temp->str);
        free(temp);
    }
}

Test(check_var, pipe_at_beginning) {
    t_token *head = create_token("|", PIPE);
    cr_expect(check_var(&head) == 1, "Expected syntax error for pipe at beginning");
    free_tokens(head);
}

Test(check_var, variable_detection) {
    t_token *head = create_token("$VAR", 0);
    cr_expect(check_var(&head) == 0, "Expected no error for variable token");
    cr_expect(head->type == VAR, "Expected token type to be VAR");
    free_tokens(head);
}

Test(check_var, consecutive_pipes) {
    t_token * head = create_token("abc", WORD);
    t_token *token1 = create_token("|", PIPE);
    t_token *token2 = create_token("|", PIPE);
    t_token *token3 = create_token("def", WORD);

    head->next = token1;
    token1->prev = head;

    token1->next = token2;
    token2->prev = token1;

    token2->next = token3;
    token3->prev = token2;
    cr_expect(check_var(&head) == 1, "Expected syntax error for consecutive pipes");
    free_tokens(head);
}

Test(check_var, mixed_valid_tokens) {
    t_token *head = create_token("echo", WORD);
    head->next = create_token("$HOME", VAR);
    head->next->prev = head;
    cr_expect(check_var(&head) == 0, "Expected no error for valid tokens");
    free_tokens(head);
}
